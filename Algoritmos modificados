#MKP con solución de partida
def AlgGenOIM(P,X,N,ProbMut):
    V=P[0]
    R=P[1]
    W=P[2]
    Y=[]
    G,g=0,0
    #Generacion de poblacion inicial
    Poblacion=Poblacion_InicialOI(R,W,N,X,V)

    #Calculo de la aptitud
    F=Np.array([Aptitud(V,x) for x in Poblacion])
    Y.append(Np.max(F))

    #Paso de las generaciones
    while g<100:
        #Creacion de la descendencia
        Descendencia=[]

        #Aplicar Elitismo
        Descendencia.append(Poblacion[Np.argmax(F)])

        while len(Descendencia)<N:
            Padre1=Torneo(Poblacion,F)
            Padre2=Torneo(Poblacion,F)

            #Cruce
            Hijo1,Hijo2=Cruce(Padre1, Padre2)

            #Mutacion
            Hijo1=MutacionOI(Hijo1,ProbMut)
            Hijo2=MutacionOI(Hijo2,ProbMut)

            #Evaluacion de factibilidad
            if Aptitud(V,Hijo1)<=int(X[0]) and EvCapacidad(R,W,Hijo1):
                Descendencia.append(Hijo1)
            if Aptitud(V,Hijo2)<=int(X[0]) and EvCapacidad(R,W,Hijo2):
                Descendencia.append(Hijo2)
        Poblacion=Descendencia
        #Calculo de la aptitud
        F=Np.array([Aptitud(V,x) for x in Poblacion])
        Y.append(Np.max(F))
        G+=1
        if Y[G-1]==Y[G]:
            g+=1
        else:
            g=0
    Grafica(Y)
    return Poblacion[Np.argmax(F)],int(Np.max(F))

#MKP sin solución de partida
def AlgGenOIM2(P,N,ProbMut):
    V=P[0]
    R=P[1]
    W=P[2]
    Y=[]
    G,g=0,0
    
    #Generacion de poblacion inicial
    Poblacion=Poblacion_InicialOI2(R,W,N,V)

    #Calculo de la aptitud
    F=Np.array([Aptitud(V,x) for x in Poblacion])
    Y.append(Np.max(F))

    #Paso de las generaciones
    while g<100:
        #Creacion de la descendencia
        Descendencia=[]

        #Aplicar Elitismo
        Descendencia.append(Poblacion[Np.argmax(F)])

        while len(Descendencia)<N:
            Padre1=Torneo(Poblacion,F)
            Padre2=Torneo(Poblacion,F)

            #Cruce
            Hijo1,Hijo2=Cruce(Padre1, Padre2)

            #Mutacion
            Hijo1=MutacionOI(Hijo1,ProbMut)
            Hijo2=MutacionOI(Hijo2,ProbMut)

            #Evaluacion de factibilidad
            if EvCapacidad(R,W,Hijo1):
                Descendencia.append(Hijo1)
    
            if EvCapacidad(R,W,Hijo2):
                Descendencia.append(Hijo2)
        Poblacion=Descendencia
        #Calculo de la aptitud
        F=Np.array([Aptitud(V,x) for x in Poblacion])
        Y.append(Np.max(F))

        G+=1
        if Y[G-1]==Y[G]:
            g+=1
        else:
            g=0
    Grafica(Y)
    return Poblacion[Np.argmax(F)],int(Np.max(F))

#MBKP con solución de partida
def AlgGenBKPM(P,X,N,ProbMut):
    V=P[0]
    R=P[1]
    W=P[2]
    B=P[3]
    Y=[]
    G,g=0,0
    #Truncamiento
    b=CapacidadLimiteBKP(R,W,B)
    Truncamiento(X[1],b)

    #Generacion de poblacion inicial
    Poblacion=Poblacion_InicialBKP(R,W,N,X,V,b)

    #Calculo de la aptitud
    F=Np.array([Aptitud(V,x) for x in Poblacion])
    Y.append(Np.max(F))
    
    #Paso de las generaciones
    while g<100:
        #Creacion de la descendencia
        Descendencia=[]

        #Aplicar Elitismo
        Descendencia.append(Poblacion[Np.argmax(F)])

        while len(Descendencia)<N:
            Padre1=Torneo(Poblacion,F)
            Padre2=Torneo(Poblacion,F)

            #Cruce
            Hijo1,Hijo2=Cruce(Padre1, Padre2)

            #Mutacion
            Hijo1=MutacionBUKP(b,Hijo1,ProbMut)
            Hijo2=MutacionBUKP(b,Hijo2,ProbMut)

            #Evaluacion de factibilidad
            if EvCapacidad(R,W,Hijo1):
                Descendencia.append(Hijo1)
            if EvCapacidad(R,W,Hijo2):
                Descendencia.append(Hijo2)
        Poblacion=Descendencia
        #Calculo de la aptitud
        F=Np.array([Aptitud(V,x) for x in Poblacion])
        Y.append(Np.max(F))
        G+=1
        if Y[G-1]==Y[G]:
            g+=1
        else:
            g=0        
    Grafica(Y)
    return Poblacion[Np.argmax(F)],int(Np.max(F))

#MBKP sin solución de partida
def AlgGenBKPM2(P,N,ProbMut):
    V=P[0]
    R=P[1]
    W=P[2]
    B=P[3]
    Y=[]
    G,g=0,0
    
    #Truncamiento
    b=CapacidadLimiteBKP(R,W,B)

    #Generacion de poblacion inicial
    Poblacion=Poblacion_InicialBKP2(R,W,N,V,b)

    #Calculo de la aptitud
    F=Np.array([Aptitud(V,x) for x in Poblacion])
    Y.append(Np.max(F))
    
    #Paso de las generaciones
    while g<100:
        #Creacion de la descendencia
        Descendencia=[]

        #Aplicar Elitismo
        Descendencia.append(Poblacion[Np.argmax(F)])

        while len(Descendencia)<N:
            Padre1=Torneo(Poblacion,F)
            Padre2=Torneo(Poblacion,F)

            #Cruce
            Hijo1,Hijo2=Cruce(Padre1, Padre2)
            #Mutacion
            Hijo1=MutacionBUKP(b,Hijo1,ProbMut)
            Hijo2=MutacionBUKP(b,Hijo2,ProbMut)

            #Evaluacion de factibilidad
            if EvCapacidad(R,W,Hijo1):
                Descendencia.append(Hijo1)
            if EvCapacidad(R,W,Hijo2):
                Descendencia.append(Hijo2)
        Poblacion=Descendencia
        #Calculo de la aptitud
        F=Np.array([Aptitud(V,x) for x in Poblacion])
        Y.append(Np.max(F))
        
        G+=1
        if Y[G-1]==Y[G]:
            g+=1
        else:
            g=0        
    Grafica(Y)
    return Poblacion[Np.argmax(F)],int(Np.max(F))

#MUKP con solución de partida
def AlgGenUKPM(P,X,N,ProbMut):
    V=P[0]
    R=P[1]
    W=P[2]
    Y=[]
    G,g=0,0
    #Truncamiento para cumplir todas las restricciones
    b=CapacidadLimiteUKP(R,W)
    Truncamiento(X[1],b)

    #Generacion de poblacion inicial
    Poblacion=Poblacion_InicialUKP(R,W,N,X,V,b)

    #Calculo de la aptitud
    F=Np.array([Aptitud(V,x) for x in Poblacion])
    Y.append(Np.max(F))
    
    #Paso de las generaciones
    while g<100:
        #Creacion de la descendencia
        Descendencia=[]

        #Aplicar Elitismo
        Descendencia.append(Poblacion[Np.argmax(F)])

        while len(Descendencia)<N:
            Padre1=Torneo(Poblacion,F)
            Padre2=Torneo(Poblacion,F)

            #Cruce
            Hijo1,Hijo2=Cruce(Padre1, Padre2)

            #Mutacion
            Hijo1=MutacionBUKP(b,Hijo1,ProbMut)
            Hijo2=MutacionBUKP(b,Hijo2,ProbMut)

            #Evaluacion de factibilidad
            if EvCapacidad(R,W,Hijo1):
                Descendencia.append(Hijo1)
            if EvCapacidad(R,W,Hijo2):
                Descendencia.append(Hijo2)
        Poblacion=Descendencia
        #Calculo de la aptitud
        F=Np.array([Aptitud(V,x) for x in Poblacion])
        Y.append(Np.max(F))
        G+=1
        if Y[G-1]==Y[G]:
            g+=1
        else:
            g=0        
    Grafica(Y)
    return Poblacion[Np.argmax(F)],int(Np.max(F))

#MUKP sin solución de partida
def AlgGenUKPM2(P,N,ProbMut):
    V=P[0]
    R=P[1]
    W=P[2]
    Y=[]
    G,g=0,0

    #Truncamiento para cumplir todas las restricciones
    b=CapacidadLimiteUKP(R,W)

    #Generacion de poblacion inicial
    Poblacion=Poblacion_InicialUKP2(R,W,N,V,b)

    #Calculo de la aptitud
    F=Np.array([Aptitud(V,x) for x in Poblacion])
    Y.append(Np.max(F))
    
    #Paso de las generaciones
    while g<100:
        #Creacion de la descendencia
        Descendencia=[]

        #Aplicar Elitismo
        Descendencia.append(Poblacion[Np.argmax(F)])

        while len(Descendencia)<N:
            Padre1=Torneo(Poblacion,F)
            Padre2=Torneo(Poblacion,F)

            #Cruce
            Hijo1,Hijo2=Cruce(Padre1, Padre2)

            #Mutacion
            Hijo1=MutacionBUKP(b,Hijo1,ProbMut)
            Hijo2=MutacionBUKP(b,Hijo2,ProbMut)

            #Evaluacion de factibilidad
            if EvCapacidad(R,W,Hijo1):
                Descendencia.append(Hijo1)
            if EvCapacidad(R,W,Hijo2):
                Descendencia.append(Hijo2)
        Poblacion=Descendencia
        #Calculo de la aptitud
        F=Np.array([Aptitud(V,x) for x in Poblacion])
        Y.append(Np.max(F))
        
        G+=1
        if Y[G-1]==Y[G]:
            g+=1
        else:
            g=0        
    Grafica(Y)
    return Poblacion[Np.argmax(F)],int(Np.max(F))

